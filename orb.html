<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ElevenLabs‑Style Orb (JS)</title>
  <style>
    :root {
      --bg1: #0b0a1a;
      --bg2: #15132b;
      --text: #cdd1ff;
    }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 800px at 50% 60%, #1c1941, var(--bg2) 45%, var(--bg1) 90%);
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
    }
    #app { position: fixed; inset: 0; }
    .hud {
      position: fixed; left: 16px; bottom: 16px; display: flex; gap: 10px; align-items: center;
      background: rgba(15, 15, 30, 0.45); border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border-radius: 14px; padding: 10px 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      user-select: none; pointer-events: none; font-size: 12px;
    }
    .hud .dot { width: 8px; height: 8px; border-radius: 50%; background: #7aa2ff; box-shadow: 0 0 12px 2px #7aa2ff; }
    #micBtn {
      position: fixed; right: 16px; bottom: 16px; padding: 10px 14px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--text);
      cursor: pointer; box-shadow: 0 8px 30px rgba(0,0,0,0.35); font-weight: 600;
      display: none; backdrop-filter: blur(6px);
    }
    #micBtn:hover { background: rgba(255,255,255,0.12); }
    .credit { position: fixed; top: 12px; left: 12px; font-size: 12px; opacity: .65; }
    a { color: #b3c4ff; text-decoration: none; }
  </style>
</head>
<body>
  <div id="app"></div>
  <button id="micBtn" title="Use your microphone to drive the orb">Enable Mic</button>
  <div class="hud"><span class="dot" id="ampDot"></span><span id="hudText">Idle</span></div>
  <div class="credit">ElevenLabs‑style orb (inspired) — pure JS/Three.js</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    // ---------- Scene Setup ----------
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 3.5);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.85, 0.9, 0.2);
    composer.addPass(bloom);

    // Lighting (subtle fill so bloom can grab highlights)
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    // ---------- Utilities ----------
    function fibonacciSphere(samples, radius = 1) {
      const pts = [];
      const offset = 2 / samples;
      const inc = Math.PI * (3 - Math.sqrt(5));
      for (let i = 0; i < samples; i++) {
        const y = i * offset - 1 + (offset / 2);
        const r = Math.sqrt(1 - y*y);
        const phi = i * inc;
        pts.push(new THREE.Vector3(
          Math.cos(phi) * r * radius,
          y * radius,
          Math.sin(phi) * r * radius
        ));
      }
      return pts;
    }

    // ---------- Shader Material (noise‑distorted point cloud) ----------
    const vertexShader = `
      uniform float uTime;
      uniform float uRadius;
      uniform float uNoiseScale;
      uniform float uDisplacement;
      uniform float uSize;
      uniform float uAmp;      // microphone (smoothed)
      uniform float uExtAmp;   // external (e.g. ElevenLabs)
      varying float vNoise;
      varying float vAmp;

      // Simplex 3D noise (Stefan Gustavson)
      vec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
      vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} 
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        // First corner
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;
        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        //  x0 = x0 - 0.0 + 0.0 * C.xxx;
        //  x1 = x0 - i1  + 1.0 * C.xxx;
        //  x2 = x0 - i2  + 2.0 * C.xxx;
        //  x3 = x0 - 1.0 + 3.0 * C.xxx;
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy;      // -1.0 + 3.0 * C.x = -0.5 = -D.y
        // Permutations
        i = mod289(i);
        vec4 p = permute( permute( permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        float n_ = 0.142857142857; // 1.0/7.0
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a1.xy,h.y);
        vec3 p2 = vec3(a0.zw,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        // Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                      dot(p2,x2), dot(p3,x3) ) );
      }

      void main() {
        float amp = max(uAmp, uExtAmp);
        vec3 dir = normalize(position);
        float n = snoise(dir * uNoiseScale + vec3(uTime * 0.35));
        float disp = (0.55 + amp * 1.75) * uDisplacement * n;
        vec3 pos = dir * (uRadius + disp);
        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mv;
        gl_PointSize = uSize * (300.0 / -mv.z) * (1.0 + amp * 0.45);
        vNoise = n; vAmp = amp;
      }
    `;

    const fragmentShader = `
      precision mediump float;
      varying float vNoise; varying float vAmp;
      uniform vec3 uColorA; uniform vec3 uColorB;
      void main(){
        // soft round points
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);
        float alpha = smoothstep(0.5, 0.28, d) * smoothstep(0.5, 0.02, 0.5 - d);
        vec3 col = mix(uColorA, uColorB, 0.5 + 0.5 * vNoise);
        col += vAmp * 0.25;
        gl_FragColor = vec4(col, alpha);
      }
    `;

    const uniforms = {
      uTime: { value: 0 },
      uRadius: { value: 1.0 },
      uNoiseScale: { value: 2.6 },
      uDisplacement: { value: 0.42 },
      uSize: { value: 2.4 },
      uAmp: { value: 0.0 },
      uExtAmp: { value: 0.0 },
      uColorA: { value: new THREE.Color('#5cc0ff').multiplyScalar(0.9) },
      uColorB: { value: new THREE.Color('#a78bfa').multiplyScalar(0.9) }
    };

    const samples = 5000;
    const points = fibonacciSphere(samples, 1);
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.ShaderMaterial({
      uniforms, vertexShader, fragmentShader,
      blending: THREE.AdditiveBlending,
      depthWrite: false, transparent: true
    });

    const cloud = new THREE.Points(geo, mat);
    scene.add(cloud);

    // A faint inner sphere for body + extra bloom
    const inner = new THREE.Mesh(
      new THREE.SphereGeometry(0.88, 64, 64),
      new THREE.MeshBasicMaterial({ color: 0x4f79ff, transparent: true, opacity: 0.08 })
    );
    scene.add(inner);

    // ---------- Audio (Mic) ----------
    const micBtn = document.getElementById('micBtn');
    const hudText = document.getElementById('hudText');
    const ampDot = document.getElementById('ampDot');
    let audioAmp = 0; // smoothed RMS 0..~0.8
    let usingMic = false;

    async function enableMic() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: {
          echoCancellation: true, noiseSuppression: true, autoGainControl: true
        }});
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        const analyser = ctx.createAnalyser();
        analyser.fftSize = 1024;
        src.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);
        usingMic = true; micBtn.style.display = 'none'; hudText.textContent = 'Mic active';
        function poll() {
          analyser.getByteTimeDomainData(data);
          // Compute RMS
          let sum = 0;
          for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128; sum += v*v;
          }
          const rms = Math.sqrt(sum / data.length); // typical up to ~0.4 for speech
          // Map and compress to 0..1
          const target = Math.min(1, (rms * 2.2));
          audioAmp = audioAmp * 0.85 + target * 0.15;
          requestAnimationFrame(poll);
        }
        poll();
      } catch (err) {
        console.warn('Mic unavailable:', err);
        micBtn.style.display = 'block';
        hudText.textContent = 'Mic blocked';
      }
    }

    // Try auto‑enable (some browsers require a user gesture; button will show if blocked)
    enableMic();
    micBtn.addEventListener('click', () => enableMic());

    // Expose a hook so you can drive the orb from an external source (e.g. ElevenLabs level)
    // Call: window.setOrbAmplitude(levelBetween0and1)
    window.setOrbAmplitude = (v) => { uniforms.uExtAmp.value = Math.max(0, Math.min(1, v||0)); };

    // ---------- Interaction ----------
    const tmp = new THREE.Vector2();
    let targetRotX = 0.15, targetRotY = 0.0;
    window.addEventListener('pointermove', (e) => {
      tmp.set((e.clientX/innerWidth) * 2 - 1, (e.clientY/innerHeight) * 2 - 1);
      targetRotY = tmp.x * 0.35; targetRotX = tmp.y * 0.25;
    });

    // ---------- Render Loop ----------
    const clock = new THREE.Clock();
    function animate() {
      const t = clock.getElapsedTime();

      // If no mic, idle pulse
      if (!usingMic) {
        const idle = (Math.sin(t*1.2) * 0.5 + 0.5) * 0.15; // 0..0.15
        audioAmp = audioAmp * 0.95 + idle * 0.05;
      }

      uniforms.uTime.value = t;
      uniforms.uAmp.value = audioAmp;

      // Visual feedback dot
      const glow = Math.min(1, 0.3 + audioAmp);
      ampDot.style.boxShadow = `0 0 ${6 + glow*18}px ${2 + glow*6}px #7aa2ff`;

      // Smooth rotation
      cloud.rotation.y += (targetRotY - cloud.rotation.y) * 0.02;
      cloud.rotation.x += (targetRotX - cloud.rotation.x) * 0.02;
      inner.rotation.copy(cloud.rotation);

      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    // ---------- Resize ----------
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      bloom.setSize(innerWidth, innerHeight);
    });

    // Optional: tweak params quickly via URL (e.g., ?points=8000)
    const params = new URLSearchParams(location.search);
    if (params.has('points')) {
      const n = Math.max(1000, Math.min(20000, parseInt(params.get('points'))||5000));
      const p = fibonacciSphere(n, 1);
      const g = new THREE.BufferGeometry().setFromPoints(p);
      cloud.geometry.dispose();
      cloud.geometry = g;
    }
  </script>
</body>
</html>
